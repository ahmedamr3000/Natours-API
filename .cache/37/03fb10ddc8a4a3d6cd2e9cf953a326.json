{"id":"../../node_modules/stripe/lib/Webhooks.js","dependencies":[{"name":"D:\\Programing\\starter\\package.json","includedInParent":true,"mtime":1745002180389},{"name":"D:\\Programing\\starter\\node_modules\\stripe\\package.json","includedInParent":true,"mtime":1745002180303},{"name":"safe-buffer","loc":{"line":3,"column":23,"index":38},"parent":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\Webhooks.js","resolved":"D:\\Programing\\starter\\node_modules\\safe-buffer\\index.js"},{"name":"crypto","loc":{"line":4,"column":23,"index":84},"parent":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\Webhooks.js","resolved":"D:\\Programing\\starter\\node_modules\\crypto-browserify\\index.js"},{"name":"./utils","loc":{"line":6,"column":22,"index":118},"parent":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\Webhooks.js","resolved":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\utils.js"},{"name":"./Error","loc":{"line":7,"column":22,"index":152},"parent":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\Webhooks.js","resolved":"D:\\Programing\\starter\\node_modules\\stripe\\lib\\Error.js"}],"generated":{"js":"\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\nvar crypto = require('crypto');\nvar utils = require('./utils');\nvar Error = require('./Error');\nvar Webhook = {\n  DEFAULT_TOLERANCE: 300,\n  // 5 minutes\n  constructEvent: function (payload, header, secret, tolerance) {\n    this.signature.verifyHeader(payload, header, secret, tolerance || Webhook.DEFAULT_TOLERANCE);\n    var jsonPayload = JSON.parse(payload);\n    return jsonPayload;\n  },\n  /**\n   * Generates a header to be used for webhook mocking\n   *\n   * @typedef {object} opts\n   * @property {number} timestamp - Timestamp of the header. Defaults to Date.now()\n   * @property {string} payload - JSON stringified payload object, containing the 'id' and 'object' parameters\n   * @property {string} secret - Stripe webhook secret 'whsec_...'\n   * @property {string} scheme - Version of API to hit. Defaults to 'v1'.\n   * @property {string} signature - Computed webhook signature\n   */\n  generateTestHeaderString: function (opts) {\n    if (!opts) {\n      throw new Error.StripeError({\n        message: 'Options are required'\n      });\n    }\n    opts.timestamp = Math.floor(opts.timestamp) || Math.floor(Date.now() / 1000);\n    opts.scheme = opts.scheme || signature.EXPECTED_SCHEME;\n    opts.signature = opts.signature || signature._computeSignature(opts.timestamp + '.' + opts.payload, opts.secret);\n    var generatedHeader = ['t=' + opts.timestamp, opts.scheme + '=' + opts.signature].join(',');\n    return generatedHeader;\n  }\n};\nvar signature = {\n  EXPECTED_SCHEME: 'v1',\n  _computeSignature: function (payload, secret) {\n    return crypto.createHmac('sha256', secret).update(payload, 'utf8').digest('hex');\n  },\n  verifyHeader: function (payload, header, secret, tolerance) {\n    payload = Buffer.isBuffer(payload) ? payload.toString('utf8') : payload;\n    header = Buffer.isBuffer(header) ? header.toString('utf8') : header;\n    var details = parseHeader(header, this.EXPECTED_SCHEME);\n    if (!details || details.timestamp === -1) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Unable to extract timestamp and signatures from header',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n    if (!details.signatures.length) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found with expected scheme',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n    var expectedSignature = this._computeSignature(\"\".concat(details.timestamp, \".\").concat(payload), secret);\n    var signatureFound = !!details.signatures.filter(utils.secureCompare.bind(utils, expectedSignature)).length;\n    if (!signatureFound) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'No signatures found matching the expected signature for payload.' + ' Are you passing the raw request body you received from Stripe?' + ' https://github.com/stripe/stripe-node#webhook-signing',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n    var timestampAge = Math.floor(Date.now() / 1000) - details.timestamp;\n    if (tolerance > 0 && timestampAge > tolerance) {\n      throw new Error.StripeSignatureVerificationError({\n        message: 'Timestamp outside the tolerance zone',\n        detail: {\n          header: header,\n          payload: payload\n        }\n      });\n    }\n    return true;\n  }\n};\nfunction parseHeader(header, scheme) {\n  if (typeof header !== 'string') {\n    return null;\n  }\n  return header.split(',').reduce(function (accum, item) {\n    var kv = item.split('=');\n    if (kv[0] === 't') {\n      accum.timestamp = kv[1];\n    }\n    if (kv[0] === scheme) {\n      accum.signatures.push(kv[1]);\n    }\n    return accum;\n  }, {\n    timestamp: -1,\n    signatures: []\n  });\n}\nWebhook.signature = signature;\nmodule.exports = Webhook;"},"sourceMaps":null,"error":null,"hash":"3e8f9d0c4f2004a3c300de6f3b4c51c6","cacheData":{"env":{}}}