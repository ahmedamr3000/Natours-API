{"id":"../../node_modules/dotenv/lib/main.js","dependencies":[{"name":"D:\\Programing\\starter\\package.json","includedInParent":true,"mtime":1745028222073},{"name":"D:\\Programing\\starter\\node_modules\\dotenv\\package.json","includedInParent":true,"mtime":1737323200000},{"name":"fs","loc":{"line":1,"column":19,"index":19},"parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\parcel-bundler\\src\\builtins\\_empty.js"},{"name":"path","loc":{"line":2,"column":21,"index":46},"parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\path-browserify\\index.js"},{"name":"os","loc":{"line":3,"column":19,"index":73},"parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\os-browserify\\browser.js"},{"name":"crypto","loc":{"line":4,"column":23,"index":102},"parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\crypto-browserify\\index.js"},{"name":"../package.json","loc":{"line":5,"column":28,"index":140},"parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\dotenv\\package.json"},{"name":"process","parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\process\\browser.js"},{"name":"buffer","parent":"D:\\Programing\\starter\\node_modules\\dotenv\\lib\\main.js","resolved":"D:\\Programing\\starter\\node_modules\\buffer\\index.js"}],"generated":{"js":"var process = require(\"process\");\nvar Buffer = require(\"buffer\").Buffer;\nfunction _typeof(o) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && \"function\" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? \"symbol\" : typeof o; }, _typeof(o); }\nfunction _createForOfIteratorHelper(r, e) { var t = \"undefined\" != typeof Symbol && r[Symbol.iterator] || r[\"@@iterator\"]; if (!t) { if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && \"number\" == typeof r.length) { t && (r = t); var _n = 0, F = function F() {}; return { s: F, n: function n() { return _n >= r.length ? { done: !0 } : { done: !1, value: r[_n++] }; }, e: function e(r) { throw r; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var o, a = !0, u = !1; return { s: function s() { t = t.call(r); }, n: function n() { var r = t.next(); return a = r.done, r; }, e: function e(r) { u = !0, o = r; }, f: function f() { try { a || null == t.return || t.return(); } finally { if (u) throw o; } } }; }\nfunction _unsupportedIterableToArray(r, a) { if (r) { if (\"string\" == typeof r) return _arrayLikeToArray(r, a); var t = {}.toString.call(r).slice(8, -1); return \"Object\" === t && r.constructor && (t = r.constructor.name), \"Map\" === t || \"Set\" === t ? Array.from(r) : \"Arguments\" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0; } }\nfunction _arrayLikeToArray(r, a) { (null == a || a > r.length) && (a = r.length); for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e]; return n; }\nvar fs = require('fs');\nvar path = require('path');\nvar os = require('os');\nvar crypto = require('crypto');\nvar packageJson = require('../package.json');\nvar version = packageJson.version;\nvar LINE = /(?:^|^)\\s*(?:export\\s+)?([\\w.-]+)(?:\\s*=\\s*?|:\\s+?)(\\s*'(?:\\\\'|[^'])*'|\\s*\"(?:\\\\\"|[^\"])*\"|\\s*`(?:\\\\`|[^`])*`|[^#\\r\\n]+)?\\s*(?:#.*)?(?:$|$)/mg;\n\n// Parse src into an Object\nfunction parse(src) {\n  var obj = {};\n\n  // Convert buffer to string\n  var lines = src.toString();\n\n  // Convert line breaks to same format\n  lines = lines.replace(/\\r\\n?/mg, '\\n');\n  var match;\n  while ((match = LINE.exec(lines)) != null) {\n    var key = match[1];\n\n    // Default undefined or null to empty string\n    var value = match[2] || '';\n\n    // Remove whitespace\n    value = value.trim();\n\n    // Check if double quoted\n    var maybeQuote = value[0];\n\n    // Remove surrounding quotes\n    value = value.replace(/^(['\"`])([\\s\\S]*)\\1$/mg, '$2');\n\n    // Expand newlines if double quoted\n    if (maybeQuote === '\"') {\n      value = value.replace(/\\\\n/g, '\\n');\n      value = value.replace(/\\\\r/g, '\\r');\n    }\n\n    // Add to object\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction _parseVault(options) {\n  var vaultPath = _vaultPath(options);\n\n  // Parse .env.vault\n  var result = DotenvModule.configDotenv({\n    path: vaultPath\n  });\n  if (!result.parsed) {\n    var err = new Error(\"MISSING_DATA: Cannot parse \".concat(vaultPath, \" for an unknown reason\"));\n    err.code = 'MISSING_DATA';\n    throw err;\n  }\n\n  // handle scenario for comma separated keys - for use with key rotation\n  // example: DOTENV_KEY=\"dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=prod,dotenv://:key_7890@dotenvx.com/vault/.env.vault?environment=prod\"\n  var keys = _dotenvKey(options).split(',');\n  var length = keys.length;\n  var decrypted;\n  for (var i = 0; i < length; i++) {\n    try {\n      // Get full key\n      var key = keys[i].trim();\n\n      // Get instructions for decrypt\n      var attrs = _instructions(result, key);\n\n      // Decrypt\n      decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);\n      break;\n    } catch (error) {\n      // last key\n      if (i + 1 >= length) {\n        throw error;\n      }\n      // try next key\n    }\n  }\n\n  // Parse decrypted .env string\n  return DotenvModule.parse(decrypted);\n}\nfunction _log(message) {\n  console.log(\"[dotenv@\".concat(version, \"][INFO] \").concat(message));\n}\nfunction _warn(message) {\n  console.log(\"[dotenv@\".concat(version, \"][WARN] \").concat(message));\n}\nfunction _debug(message) {\n  console.log(\"[dotenv@\".concat(version, \"][DEBUG] \").concat(message));\n}\nfunction _dotenvKey(options) {\n  // prioritize developer directly setting options.DOTENV_KEY\n  if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {\n    return options.DOTENV_KEY;\n  }\n\n  // secondary infra already contains a DOTENV_KEY environment variable\n  if (undefined && undefined.length > 0) {\n    return undefined;\n  }\n\n  // fallback to empty string\n  return '';\n}\nfunction _instructions(result, dotenvKey) {\n  // Parse DOTENV_KEY. Format is a URI\n  var uri;\n  try {\n    uri = new URL(dotenvKey);\n  } catch (error) {\n    if (error.code === 'ERR_INVALID_URL') {\n      var err = new Error('INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development');\n      err.code = 'INVALID_DOTENV_KEY';\n      throw err;\n    }\n    throw error;\n  }\n\n  // Get decrypt key\n  var key = uri.password;\n  if (!key) {\n    var _err = new Error('INVALID_DOTENV_KEY: Missing key part');\n    _err.code = 'INVALID_DOTENV_KEY';\n    throw _err;\n  }\n\n  // Get environment\n  var environment = uri.searchParams.get('environment');\n  if (!environment) {\n    var _err2 = new Error('INVALID_DOTENV_KEY: Missing environment part');\n    _err2.code = 'INVALID_DOTENV_KEY';\n    throw _err2;\n  }\n\n  // Get ciphertext payload\n  var environmentKey = \"DOTENV_VAULT_\".concat(environment.toUpperCase());\n  var ciphertext = result.parsed[environmentKey]; // DOTENV_VAULT_PRODUCTION\n  if (!ciphertext) {\n    var _err3 = new Error(\"NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment \".concat(environmentKey, \" in your .env.vault file.\"));\n    _err3.code = 'NOT_FOUND_DOTENV_ENVIRONMENT';\n    throw _err3;\n  }\n  return {\n    ciphertext: ciphertext,\n    key: key\n  };\n}\nfunction _vaultPath(options) {\n  var possibleVaultPath = null;\n  if (options && options.path && options.path.length > 0) {\n    if (Array.isArray(options.path)) {\n      var _iterator = _createForOfIteratorHelper(options.path),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var filepath = _step.value;\n          if (fs.existsSync(filepath)) {\n            possibleVaultPath = filepath.endsWith('.vault') ? filepath : \"\".concat(filepath, \".vault\");\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    } else {\n      possibleVaultPath = options.path.endsWith('.vault') ? options.path : \"\".concat(options.path, \".vault\");\n    }\n  } else {\n    possibleVaultPath = path.resolve(process.cwd(), '.env.vault');\n  }\n  if (fs.existsSync(possibleVaultPath)) {\n    return possibleVaultPath;\n  }\n  return null;\n}\nfunction _resolveHome(envPath) {\n  return envPath[0] === '~' ? path.join(os.homedir(), envPath.slice(1)) : envPath;\n}\nfunction _configVault(options) {\n  _log('Loading env from encrypted .env.vault');\n  var parsed = DotenvModule._parseVault(options);\n  var processEnv = process.env;\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv;\n  }\n  DotenvModule.populate(processEnv, parsed, options);\n  return {\n    parsed: parsed\n  };\n}\nfunction configDotenv(options) {\n  var dotenvPath = path.resolve(process.cwd(), '.env');\n  var encoding = 'utf8';\n  var debug = Boolean(options && options.debug);\n  if (options && options.encoding) {\n    encoding = options.encoding;\n  } else {\n    if (debug) {\n      _debug('No encoding is specified. UTF-8 is used by default');\n    }\n  }\n  var optionPaths = [dotenvPath]; // default, look for .env\n  if (options && options.path) {\n    if (!Array.isArray(options.path)) {\n      optionPaths = [_resolveHome(options.path)];\n    } else {\n      optionPaths = []; // reset default\n      var _iterator2 = _createForOfIteratorHelper(options.path),\n        _step2;\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var filepath = _step2.value;\n          optionPaths.push(_resolveHome(filepath));\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n    }\n  }\n\n  // Build the parsed data in a temporary object (because we need to return it).  Once we have the final\n  // parsed data, we will combine it with process.env (or options.processEnv if provided).\n  var lastError;\n  var parsedAll = {};\n  for (var _i = 0, _optionPaths = optionPaths; _i < _optionPaths.length; _i++) {\n    var _path = _optionPaths[_i];\n    try {\n      // Specifying an encoding returns a string instead of a buffer\n      var parsed = DotenvModule.parse(fs.readFileSync(_path, {\n        encoding: encoding\n      }));\n      DotenvModule.populate(parsedAll, parsed, options);\n    } catch (e) {\n      if (debug) {\n        _debug(\"Failed to load \".concat(_path, \" \").concat(e.message));\n      }\n      lastError = e;\n    }\n  }\n  var processEnv = process.env;\n  if (options && options.processEnv != null) {\n    processEnv = options.processEnv;\n  }\n  DotenvModule.populate(processEnv, parsedAll, options);\n  if (lastError) {\n    return {\n      parsed: parsedAll,\n      error: lastError\n    };\n  } else {\n    return {\n      parsed: parsedAll\n    };\n  }\n}\n\n// Populates process.env from .env file\nfunction config(options) {\n  // fallback to original dotenv if DOTENV_KEY is not set\n  if (_dotenvKey(options).length === 0) {\n    return DotenvModule.configDotenv(options);\n  }\n  var vaultPath = _vaultPath(options);\n\n  // dotenvKey exists but .env.vault file does not exist\n  if (!vaultPath) {\n    _warn(\"You set DOTENV_KEY but you are missing a .env.vault file at \".concat(vaultPath, \". Did you forget to build it?\"));\n    return DotenvModule.configDotenv(options);\n  }\n  return DotenvModule._configVault(options);\n}\nfunction decrypt(encrypted, keyStr) {\n  var key = Buffer.from(keyStr.slice(-64), 'hex');\n  var ciphertext = Buffer.from(encrypted, 'base64');\n  var nonce = ciphertext.subarray(0, 12);\n  var authTag = ciphertext.subarray(-16);\n  ciphertext = ciphertext.subarray(12, -16);\n  try {\n    var aesgcm = crypto.createDecipheriv('aes-256-gcm', key, nonce);\n    aesgcm.setAuthTag(authTag);\n    return \"\".concat(aesgcm.update(ciphertext)).concat(aesgcm.final());\n  } catch (error) {\n    var isRange = error instanceof RangeError;\n    var invalidKeyLength = error.message === 'Invalid key length';\n    var decryptionFailed = error.message === 'Unsupported state or unable to authenticate data';\n    if (isRange || invalidKeyLength) {\n      var err = new Error('INVALID_DOTENV_KEY: It must be 64 characters long (or more)');\n      err.code = 'INVALID_DOTENV_KEY';\n      throw err;\n    } else if (decryptionFailed) {\n      var _err4 = new Error('DECRYPTION_FAILED: Please check your DOTENV_KEY');\n      _err4.code = 'DECRYPTION_FAILED';\n      throw _err4;\n    } else {\n      throw error;\n    }\n  }\n}\n\n// Populate process.env with parsed values\nfunction populate(processEnv, parsed) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var debug = Boolean(options && options.debug);\n  var override = Boolean(options && options.override);\n  if (_typeof(parsed) !== 'object') {\n    var err = new Error('OBJECT_REQUIRED: Please check the processEnv argument being passed to populate');\n    err.code = 'OBJECT_REQUIRED';\n    throw err;\n  }\n\n  // Set process.env\n  for (var _i2 = 0, _Object$keys = Object.keys(parsed); _i2 < _Object$keys.length; _i2++) {\n    var key = _Object$keys[_i2];\n    if (Object.prototype.hasOwnProperty.call(processEnv, key)) {\n      if (override === true) {\n        processEnv[key] = parsed[key];\n      }\n      if (debug) {\n        if (override === true) {\n          _debug(\"\\\"\".concat(key, \"\\\" is already defined and WAS overwritten\"));\n        } else {\n          _debug(\"\\\"\".concat(key, \"\\\" is already defined and was NOT overwritten\"));\n        }\n      }\n    } else {\n      processEnv[key] = parsed[key];\n    }\n  }\n}\nvar DotenvModule = {\n  configDotenv: configDotenv,\n  _configVault: _configVault,\n  _parseVault: _parseVault,\n  config: config,\n  decrypt: decrypt,\n  parse: parse,\n  populate: populate\n};\nmodule.exports.configDotenv = DotenvModule.configDotenv;\nmodule.exports._configVault = DotenvModule._configVault;\nmodule.exports._parseVault = DotenvModule._parseVault;\nmodule.exports.config = DotenvModule.config;\nmodule.exports.decrypt = DotenvModule.decrypt;\nmodule.exports.parse = DotenvModule.parse;\nmodule.exports.populate = DotenvModule.populate;\nmodule.exports = DotenvModule;"},"sourceMaps":null,"error":null,"hash":"83c92776595fe86f6d2d60f933ec02ad","cacheData":{"env":{}}}